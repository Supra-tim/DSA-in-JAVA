# DSA-in-JAVA
Comprehensive repository containing implementations of all major Data Structures and Algorithms topics with clean, well-documented code.

# Basic Data Structures

Array – Sequential collection of elements with index-based access.

String – Immutable sequence of characters used for text processing.

Linked List – Dynamic linear structure with nodes connected by pointers.

Stack – LIFO (Last-In-First-Out) structure supporting push and pop operations.

Queue – FIFO (First-In-First-Out) structure supporting enqueue and dequeue.

Deque (Double Ended Queue) – Queue allowing insertion/deletion at both ends.

Hashing / Hash Table – Key-value mapping for constant-time access and search.

Set – Collection of unique elements for fast membership tests.

Map / Dictionary – Stores key-value pairs with efficient lookups.

# Advanced Data Structures

Binary Tree – Hierarchical structure with nodes having up to two children.

Binary Search Tree (BST) – Binary tree with ordered node arrangement for fast search.

Heap / Priority Queue – Complete binary tree used for efficient min/max retrieval.

Trie (Prefix Tree) – Specialized tree for string and prefix-based searching.

Graph – Collection of vertices and edges representing relationships.

Segment Tree – Tree structure for efficient range queries and updates.

Fenwick Tree (Binary Indexed Tree) – Optimized structure for cumulative frequency/range queries.

Disjoint Set (Union-Find) – Structure for tracking connected components.

# Sorting Algorithms

Bubble Sort – Repeatedly swaps adjacent elements until sorted.

Selection Sort – Selects the smallest/largest element and places it at the correct position.

Insertion Sort – Builds the sorted list by inserting elements in the correct place.

Merge Sort – Divide-and-conquer algorithm that merges sorted halves.

Quick Sort – Partition-based sorting using a pivot element.

Heap Sort – Sorting using heap data structure for O(n log n) performance.

Counting Sort – Sorting by counting occurrences of elements.

Radix Sort – Digit-based non-comparison sorting algorithm.

Bucket Sort – Distributes elements into buckets and sorts individually.

# Searching Algorithms

Linear Search – Sequentially checks each element for the target.

Binary Search – Efficient search in a sorted array by halving the range.

Jump Search – Skips fixed steps to reduce comparisons in sorted arrays.

Interpolation Search – Improves binary search using position estimation.

Exponential Search – Finds range exponentially, then applies binary search.

# Graph Algorithms

BFS (Breadth-First Search) – Level-wise traversal of a graph.

DFS (Depth-First Search) – Recursive/stack-based traversal of a graph.

Dijkstra’s Algorithm – Shortest path algorithm for weighted graphs.

Bellman-Ford Algorithm – Finds shortest paths, works with negative weights.

Floyd-Warshall Algorithm – Computes shortest paths between all pairs of vertices.

Kruskal’s Algorithm – Minimum Spanning Tree algorithm using edge sorting.

Prim’s Algorithm – Minimum Spanning Tree algorithm using greedy selection.

Topological Sort – Orders vertices in a directed acyclic graph (DAG).

Kosaraju’s Algorithm – Finds strongly connected components in a graph.

Tarjan’s Algorithm – Detects strongly connected components efficiently.

# Dynamic Programming

Fibonacci Sequence (DP) – Computes Fibonacci numbers using memoization/tabulation.

Longest Common Subsequence (LCS) – Finds longest subsequence common to two strings.

Longest Increasing Subsequence (LIS) – Finds longest strictly increasing subsequence.

Knapsack Problem (0/1, Fractional, Unbounded) – Optimizes item selection under weight constraints.

Matrix Chain Multiplication – Optimal parenthesization of matrix multiplications.

Coin Change Problem – Finds minimum/total ways to make change.

Edit Distance (Levenshtein) – Minimum operations to convert one string to another.

Subset Sum Problem – Determines if a subset with given sum exists.

Rod Cutting Problem – Maximizes profit by cutting rods optimally.

# Greedy Algorithms

Activity Selection – Selects maximum number of non-overlapping activities.

Huffman Coding – Compression using optimal prefix codes.

Job Sequencing with Deadlines – Maximizes profit by scheduling jobs optimally.

Fractional Knapsack – Optimizes selection when fractions of items are allowed.

# Other Important Topics

Backtracking – Systematically searches for solutions by trying and undoing steps.

Recursion – Function calling itself for problem-solving.

Divide and Conquer – Breaks problem into subproblems and combines solutions.

Bit Manipulation – Uses bitwise operators for optimized computations.

Mathematical Algorithms – Includes GCD, LCM, prime checks, modular exponentiation.

Sliding Window – Optimizes subarray/substring problems with a moving window.

Two Pointer Technique – Uses two indices to solve array/string problems efficiently.

Also some leetcode problems will be added**
